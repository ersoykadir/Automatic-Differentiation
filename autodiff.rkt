#lang racket
(provide (all-defined-out))
;; given
(struct num (value grad)
    #:property prop:custom-write
    (lambda (num port write?)
        (fprintf port (if write? "(num ~s ~s)" "(num ~a ~a)")
            (num-value num) (num-grad num))))
;; given
(define relu (lambda (x) (if (> (num-value x) 0) x (num 0.0 0.0))))
;; given
(define mse (lambda (x y) (mul (sub x y) (sub x y))))
(define (get-value num-list)
    (if (list? num-list) 
    (map num-value num-list) (num-value num-list)
    ))
(define (get-grad num-list)
    (if (list? num-list) 
    (map num-grad num-list) (num-grad num-list)
    ))
(define (sub num1 num2)
    (num (- (num-value num1) (num-value num2)) (- (num-grad num1) (num-grad num2)))
    )
(define (add . args)
    (let ((v-list (get-value args)) (g-list (get-grad args)))
    (num (apply + v-list) (apply + g-list))
    ))
(define (listcheck ls)
    (if (list? ls)
        ls
        (list ls)
    )
)
(define (grad-mul v-list g-list head)
    (if (eq? head (car v-list))
        0
        (+ (foldl * (car g-list) (listcheck (cdr v-list)))       
            (grad-mul 
                (append (listcheck (cdr v-list)) (listcheck (car v-list))) 
                (append (listcheck (cdr g-list)) (listcheck (car g-list))) 
                head)
        )
    ))

(define (mul . args);num 5 1 num 2 1
    (let ((v-list (get-value args)) (g-list (get-grad args)))
        (num (apply * v-list) 
            (+ (foldl * (car g-list) (listcheck (cdr v-list)))       
            (grad-mul 
                (append (listcheck (cdr v-list)) (listcheck (car v-list))) 
                (append (listcheck (cdr g-list)) (listcheck (car g-list))) 
                (car v-list))
        )
        )
    )
)
(define (chash name val var)
    (if (eqv? var name)
        (num val 1.0)
        (num val 0.0)
    ))
(define (varlist names var)
    (if (null? names)
        '()
        ;(foldl list var (varlist (cdr names) var)) 
        (append (list var) (varlist (cdr names) var))
        ;(list var (varlist (cdr names) var))
    ))
(define (comb-two-list lis1 lis2)
    (if (null? lis1)
        '()
        (append (list (car lis1) (car lis2)) (comb-two-list (cdr lis1) (cdr lis2)) )
    )
)
(define (create-hash names values var)
    (let ((ls (map chash names values (varlist names var))))
        (make-hash (map cons names ls))
    )        
)
(define (get-val sym hash)
    (if (number? sym) 
        (num sym 0.0)
        (hash-ref hash sym)
    )
)
(define (parse hash expr)
    (cond 
        ((null? expr) '()) 
        ((list? expr) (cons (parse hash (car expr)) (parse hash (cdr expr)) ))
        ((eqv? '+ expr) 'add )
        ((eqv? '* expr) 'mul)
        ((eqv? '- expr) 'sub)
        ((eqv? 'relu expr) 'relu)
        ((eqv? 'mse expr) 'mse)
        ((number? expr) (num expr 0.0))
        (else (hash-ref hash expr))
    )
)
(define (grad names values var expr)
    (let ((hash (create-hash names values var)))
        ((parse hash expr))
    )
)
;(parse (create-hash '(x y) '(10 20) 'x)
 ;       '(+ (* (+ x y) x) (+ y x 5)))

;(let ((opr (car expr)) (vars (cdr expr)))
;        (cond ((null? vars) (get-val opr hash) )
;            ((eqv? '+ opr) (cons 'add (parse-hash hash vars))) 
;            ((eqv? '* opr) (cons 'mul (parse-hash hash vars)))
;            ((eqv? '- opr) (cons 'sub (parse-hash hash vars)))
;            ((list? opr) (parse-hash hash (cons (parse-hash hash opr)(parse-hash hash vars)) ) )
;            (else ((if (number? opr) (list (get-val opr hash) (parse-hash hash vars)) (cons (parse-hash hash opr) (parse-hash hash vars))    )) )
;        )
;    )
(define (append lis1 lis2)
    (cond ((null? lis1) lis2)
        (else (cons (car lis1)
                (append (cdr lis1) lis2)
            )
        )
    )
)