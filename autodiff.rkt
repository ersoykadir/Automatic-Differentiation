#lang racket
(provide (all-defined-out))
;; given
(struct num (value grad)
    #:property prop:custom-write
    (lambda (num port write?)
        (fprintf port (if write? "(num ~s ~s)" "(num ~a ~a)")
            (num-value num) (num-grad num))))
;; given
(define relu (lambda (x) (if (> (num-value x) 0) x (num 0.0 0.0))))
;; given
(define mse (lambda (x y) (mul (sub x y) (sub x y))))
(define (get-value num-list)
    (if (list? num-list) 
    (map num-value num-list) (num-value num-list)
    ))
(define (get-grad num-list)
    (if (list? num-list) 
    (map num-grad num-list) (num-grad num-list)
    ))
(define (sub num1 num2)
    (num (- (num-value num1) (num-value num2)) (- (num-grad num1) (num-grad num2)))
    )
(define (add . args)
    (let ((v-list (get-value args)) (g-list (get-grad args)))
    (num (apply + v-list) (apply + g-list))
    ))
(define (listcheck ls)
    (if (list? ls)
        ls
        (list ls)
    )
)
(define (grad-mul args len)
    (if (eqv? len 0)
        0
        (+ (foldl * (num-grad(car args)) (listcheck (get-value(cdr args))))       
            (grad-mul 
                (append (listcheck (cdr args)) (listcheck (car args))) 
                (- len 1))
        )
    ))
(define (len list)
    (if (null? list)
        0
        (+ 1 (len (cdr list)))
    )
)
(define (mul . args);num 5 1 num 2 1
    (let ((v-list (get-value args)))
        (num (apply * v-list) 
            (+ (foldl * (num-grad(car args)) (listcheck (get-value(cdr args))))      
                (grad-mul 
                    (append (listcheck (cdr args)) (listcheck (car args))) 
                    (- (len args) 1)
                )
            )
        )
    )
)
(define (chash name val var)
    (if (eqv? var name)
        (num val 1.0)
        (num val 0.0)
    ))
(define (varlist names var)
    (if (null? names)
        '()
        ;(foldl list var (varlist (cdr names) var)) 
        (append (list var) (varlist (cdr names) var))
        ;(list var (varlist (cdr names) var))
    ))
(define (comb-two-list lis1 lis2)
    (if (null? lis1)
        '()
        (append (list (car lis1) (car lis2)) (comb-two-list (cdr lis1) (cdr lis2)) )
    )
)
(define (create-hash names values var)
    (let ((ls (map chash names values (varlist names var))))
        (make-hash (map cons names ls))
    )        
)
(define (get-val sym hash)
    (if (number? sym) 
        (num sym 0.0)
        (hash-ref hash sym)
    )
)
(define (parse hash expr)
    (cond 
        ((null? expr) '()) 
        ((list? expr) (cons (parse hash (car expr)) (parse hash (cdr expr)) ))
        ((eqv? '+ expr) 'add )
        ((eqv? '* expr) 'mul)
        ((eqv? '- expr) 'sub)
        ((eqv? 'relu expr) 'relu)
        ((eqv? 'mse expr) 'mse)
        ((number? expr) (num expr 0.0))
        (else (hash-ref hash expr))
    )
)
(define (grad names values var expr)
    (let ((hash (create-hash names values var)))
        (num-grad (eval (parse hash expr)))
    )
)(define (partial-grad names values vars expr)
    (get-partial-grad names values vars expr names)
)
(define (get-partial-grad names values vars expr head)
    (if (null? vars)
        (if (null? head) 
            '()
            (append '(0.0) (get-partial-grad names values vars expr (cdr head)) )
        )
        (if (eqv? (car head) (car vars)) 
            (append (listcheck (grad names values (car vars) expr)) (listcheck (get-partial-grad names values (cdr vars) expr (cdr head) )))   
            (append '(0.0) (listcheck (get-partial-grad names values vars expr (cdr head) )) )
        )
    )
)
(define (gradient-descent names values vars lr expr )
    (map - values (map * (varlist names lr) (partial-grad names values vars expr)) 
    )
)
(define (optimize names values vars lr k expr )
    (if (eqv? k 1)
        (gradient-descent names values vars lr expr )
        (gradient-descent names (optimize names values vars lr (- k 1) expr ) vars lr expr)
    )
)
;(parse (create-hash '(x y) '(10 20) 'x)
 ;       '(+ (* (+ x y) x) (+ y x 5)))
;(let ((opr (car expr)) (vars (cdr expr)))
;        (cond ((null? vars) (get-val opr hash) )
;            ((eqv? '+ opr) (cons 'add (parse-hash hash vars))) 
;            ((eqv? '* opr) (cons 'mul (parse-hash hash vars)))
;            ((eqv? '- opr) (cons 'sub (parse-hash hash vars)))
;            ((list? opr) (parse-hash hash (cons (parse-hash hash opr)(parse-hash hash vars)) ) )
;            (else ((if (number? opr) (list (get-val opr hash) (parse-hash hash vars)) (cons (parse-hash hash opr) (parse-hash hash vars))    )) )
;        )
;    )
(define (append lis1 lis2)
    (cond ((null? lis1) lis2)
        (else (cons (car lis1)
                (append (cdr lis1) lis2)
            )
        )
    )
)